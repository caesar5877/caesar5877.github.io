**Emoji 广播系统（Emoji Broadcasting System）**

这个系统旨在为 Facebook Live 提供 Emoji 广播功能。当用户观看直播时，他们可以通过发送表情符号（Emoji）来表达反应，这些表情符号会扇出（fan out）给所有观看直播的用户。

**1. 系统目标与功能（Introduction & Goals）**
*   **目的**：让用户感受到观看者的集体情绪，增强参与感。
*   **体验**：表情符号会暂时出现在每个观看者的屏幕上，然后消失。
*   **Emoji**：预定义的一组表情符号。
*   **用户**：所有观看直播的用户都受到平等对待，不区分 VIP 用户。
*   **回放**：系统不要求支持离线回放功能。

**2. 非功能性需求（Non-Functional Requirements）**
*   **用户规模**：支持 1 亿日活跃用户（DAU），分布全球，但大多数用户在北美。
*   **直播规模**：需要支持名人用户和热门直播，单个直播可以支持数千万用户。
*   **准确性**：在表情符号过多时，可以权衡，提供良好的用户体验，例如，避免表情符号泛滥导致设备卡顿或遮挡屏幕。
*   **实时性**：表情符号应尽快交付，因为延迟或不合时宜的表情会造成困惑。
*   **一致性**：不要求 Emoji 与流的特定帧精确同步，只需尽快发送即可。
*   **持久性**：偶尔丢失一些表情符号是可接受的，但应尽可能多地收集表情符号数据点，因为将来可能用于设计更精确的展示方式。

**3. API 定义（API Definition）**
系统需要以下核心 API：
*   `watch_stream(user_id, stream_id) → websocket_address`：用户点击进入直播时调用，将客户端重定向到 WebSocket 实例。
*   `send_emoji(user_id, stream_id, emoji_id) → status`：用户在直播中发送表情符号时调用。成功状态意味着服务器已收到消息并正在扇出。
*   `display_emoji(emojis)`：客户端回调函数，用于在观看者屏幕上显示表情符号。

**4. 高层架构图（High-Level Diagram）**
*   用户通过 WebSocket 服务器连接观看直播。
*   `send_emoji` 请求通过一个消息队列（Emoji Queue）进入扇出服务（Fan-Out Service）。
*   扇出服务根据连接存储（Connection Storage）的信息，将表情符号转发给相应的 WebSocket 服务器。
*   WebSocket 服务器维护 `stream_id` 到连接列表的映射，并将表情符号推送到客户端。

**5. 模式和数据结构（Schema and Data Structures）**
*   **表情队列（Emoji Queue）**：存储 `Stream Id` 和 `Emoji Id`。
*   **连接存储（Connection Storage）**：存储 `stream_id → [websocket_server_id]` 的映射，用于扇出服务查找目标 WebSocket 服务器。
*   **WebSocket 服务器**：每个服务器维护 `stream_id → [connection]` 的映射，其中 `connection` 包含用于转发请求的 IP 和端口。

**6. 端到端流程（End to End Flow）**
1.  用户调用 `watch_stream`，通知 WebSocket 服务器将连接添加到其 `stream_id → [connection]` 映射中，并更新连接存储中的 `websocket_server_id`。
2.  用户断开连接时，连接从 WebSocket 服务器中移除；如果该流的连接列表为空，则发送请求从连接存储中移除 `websocket_server_id`。
3.  `send_emoji` 调用将消息发送到队列，然后由扇出服务处理。
4.  扇出服务从连接存储中查找给定 `stream_id` 的 `websocket_server_id` 列表，并将请求转发到这些服务器。
5.  WebSocket 服务器根据其 `stream_id → [connection]` 映射，将表情符号转发给所有连接的客户端。

**7. 深层讨论（Deep Dives）—— 所有痛点解释**

以下是该系统设计中的主要痛点和讨论：

*   **扇出因子（Fan-out Factor）**
    *   **问题**：当一个直播有数千万并发观看者时，如果所有人都同时发送表情符号，将导致巨大的“惊群问题”（thundering herd problem），QPS 可能达到百万级别。这会使设备不堪重负，并可能覆盖用户屏幕，导致糟糕的用户体验。
    *   **方案一：直接扇出**
        *   **方法**：通过分片（sharding）来扩展流服务和表情队列以处理高 QPS。扇出服务可以进行微批处理（micro-batches）。
        *   **权衡**：即使系统能勉强工作，也可能出现大量积压，导致表情符号广播延迟。此外，用户收到的表情符号数量会让人应接不暇，屏幕被大量表情符号覆盖也无助于用户体验。
    *   **方案二：客户端采样（Client-Side Sample）**
        *   **方法**：当用户数量增多时，表情符号的准确性变得不那么重要，因为会有大量重叠的表情。客户端可以根据并发观看者数量进行采样。例如，对于千万级别的直播，每次点击发送的概率可能只有 0.01%。
        *   **权衡**：即使概率很低，仍会有足够的表情符号被处理，同时显著降低 QPS，提供可预测的流量，改善用户体验。
    *   **方案三：扇出服务采样（Fan-Out Service Sample）**
        *   **方法**：扇出服务每秒聚合一次每个表情符号的计数（`Stream Id | Emoji Id | Count`）。当计数很高（例如，超过 20 个）时，不要在一秒内显示 20 多个表情符号，而是与 UI 团队合作，显示一个“表情雨”（emoji confetti）动画，表明很多人发送了该表情符号。
        *   **权衡**：一个计数为 20 和 1000 的表情雨在视觉上可能相同，有效减少了需要实际显示和处理的表情数量，从而降低了 WebSocket 服务器的负载并改善了用户体验。
    *   **结论**：结合方案二和方案三。方案二用于减少流服务和表情队列的吞吐量，方案三用于减少 WebSocket 服务器的扇出负担并改善用户体验。

*   **连接存储复杂性（Connection Storage Complexity）**
    *   **问题**：扇出服务需要知道将表情符号转发给哪些 WebSocket 服务器。当前设计需要随着连接的增加和移除不断更新连接存储（`stream_id → [websocket_server_id]`）。如果连接频繁打开和关闭，更新连接存储的 QPS 可能很高，成为挑战。
    *   **方案一：始终扇出到所有 WebSocket 服务器**
        *   **方法**：不维护连接存储，直接向所有可用的 WebSocket 服务器广播表情符号。
        *   **权衡**：优点是简化了设计，无需更新连接存储。缺点是成本可能过高，特别是对于观看者很少的直播。例如，如果一个流只有一个观看者，但有 1000 个 WebSocket 服务器，每次表情符号发送都需要转发 1000 次，这会造成大量浪费。Facebook Live 的视频分布呈长尾效应，大多数视频观看者不多。
    *   **方案二：使用连接存储（现有设计）**
        *   **方法**：维护 `stream_id → [websocket_server_id]` 的映射，并在连接增删时更新。
        *   **权衡**：挑战在于更新连接存储的高 QPS，以及扇出服务在读取 `websocket_server_ids` 时可能导致的轻微延迟。
    *   **结论**：鉴于长尾视频带来的巨大扇出因子，维护连接存储以减少 WebSocket 服务器负载的复杂性是值得的。如果只有 1-3 个服务器需要处理，而不是 120 个，这将是巨大的节省。

*   **全球分布式用户案例（Globally Distributed User Case）**
    *   **问题**：如何为全球分布的用户（例如 3 个区域）提供服务？一个区域的直播需要知道哪些其他区域也在观看同一流。
    *   **方案一：将 Emoji 转发到所有区域**
        *   **方法**：每次表情符号请求都转发到所有 3 个区域。
        *   **权衡**：优点是简单，不需要区域连接存储。缺点是如果某个区域没有用户观看该流，转发就会浪费。但鉴于区域数量不多（3 个，而不是 120 个 WebSocket 服务器），这种浪费是可以接受的。
    *   **方案二：拥有一个全球区域连接存储**
        *   **方法**：在每个区域维护一个 `stream_id → [region_id]` 的区域连接存储。更新本地连接存储时，需要广播更改到其他区域。扇出服务会查找本地的 `websocket_server_ids` 和其他区域以转发请求。
        *   **权衡**：维护全球连接存储的复杂性显著高于区域连接存储。
    *   **结论**：对于区域设计，倾向于选择方案一（始终广播），而不是维护全球连接存储。因为扇出因子只有 3，相对于 120 个 WebSocket 服务器的扇出情况，复杂性不值得。并且在一个区域内，用户观看特定流的概率高于单个服务器。

*   **连接存储设计（Connection Store Design）**
    *   **问题**：连接存储的读取路径存在高 QPS 问题。批处理 1000 个表情符号可能产生 100,000 个块，每个块对数据存储进行一次调用，峰值读取吞吐量可能达到 10,000 QPS，存在风险。
    *   **方案一：使用持久化存储（Durable Store）**
        *   **方法**：使用持久化键值存储。
        *   **权衡**：优点是键值查找高效，耐久性强。读取延迟对于这种扇出场景可以接受。但 10,000 QPS 对于磁盘存储来说很高，可能需要分片，增加了复杂性。
    *   **方案二：使用缓存（Cache）**
        *   **方法**：使用缓存存储连接信息。
        *   **权衡**：优点是缓存能够处理 10,000 QPS。缺点是缓存崩溃时重建的复杂性，以及数据更改时缓存失效的复杂性。可以考虑定期备份，即使数据可能不新鲜。系统可以接受一定程度的不一致性，以换取可用性。
    *   **方案三：结合持久化存储和读写缓存（Durable Stores with Read-Through Cache）**
        *   **方法**：数据库作为真理之源（source of truth），读写缓存处理读取。
        *   **权衡**：优点是数据一致性更好。缺点是失效复杂性。在数据更新时，幂等删除可能导致偶尔的缓存未命中，从而导致连接更新时延迟不可预测。
    *   **结论**：方案二和方案三都是不错的选择。方案一因需要分片来扩展 QPS 而过于复杂。方案三的一致性更好，但方案二更简单，只有一个带备份的缓存集群，代价是可能存在不一致性。候选人倾向于方案二，因为连接经常变化，并且因断开连接而本身就存在不一致性。

*   **WebSocket 负载均衡（Load Balance WebSocket）**
    *   **问题**：如何在多个 WebSocket 服务器之间进行负载均衡？在最坏情况下，如果一个流的每个 WebSocket 服务器上至少有一个观看者，那么一个表情符号需要广播到所有这些服务器。
    *   **方案一：基于流 ID 分配**
        *   **方法**：每个流只托管在一个特定的 WebSocket 服务器上。
        *   **权衡**：优点是扇出服务只需将请求转发到一个 WebSocket 服务器。缺点是连接变为有状态，难以扩展。热门流会形成热点，需要进一步将流分片为微分片（micro-shards），并在扇出时广播到所有微分片。
    *   **方案二：轮询（Round Robin）**
        *   **方法**：用户连接到流时，通过轮询分配到下一个可用的 WebSocket 服务器。
        *   **权衡**：优点是 WebSocket 服务器是无状态的，可以通过增加服务器来扩展。缺点是扇出时，如果同一流托管在多个 WebSocket 服务器上，则需要向所有这些服务器进行扇出（通过连接存储）。
    *   **结论**：原来的轮询方案（方案二）已经足够好，方案一（有状态）对于需要多个微分片的热门视频并没有增加太多价值。如果规模较小，每个流不需要多个 WebSocket 服务器，则方案一可能更可取。

*   **流回放（Stream Replay）**
    *   **问题**：支持流回放，需要将表情符号映射到流中的特定时间点。
    *   **方案一：使用客户端时钟存储 Emoji 时间戳**
        *   **方法**：用户每次点击发送表情符号时，记录流的相对时间戳并存储。回放时，使用该时间戳在相应时间显示表情符号。
        *   **权衡**：优点是表情符号时间戳精确反映了用户意图点击的帧。缺点是可能导致表情符号泛滥（需要采样），并且增加了存储每个点击的开销。
    *   **方案二：使用流服务时钟存储 Emoji 时间戳**
        *   **方法**：不使用客户端时钟，而是在收到表情符号时使用服务器时钟生成时间戳。
        *   **权衡**：缺点与方案一类似，但可以防止恶意用户篡改时间戳。
    *   **方案三：使用扇出服务时钟**
        *   **方法**：利用现有处理流程，扇出服务将要广播的表情符号列表持久化，并协调流服务以确定表情符号的相对时间戳（例如 `(stream_id, time_slice) → [emoji_id]`）。
        *   **权衡**：优点是重用了现有基础设施。缺点是可能与用户意图不一致。
    *   **结论**：方案三类似于实际生产中的做法。
